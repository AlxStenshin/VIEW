{
  "name": "sensor_tsl2561",
  "version": "0.2.2",
  "description": "A node.js-module for the TSL2561 light sensor",
  "main": "tsl2561.js",
  "dependencies": {
    "i2c": "~0.1.4",
    "underscore": "~1.5.2",
    "async": "~0.2.9",
    "proxyquire": "~0.5.2"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": {
    "name": "Thomas Schneider"
  },
  "devDependencies": {
    "grunt": "~0.4.2",
    "grunt-jsbeautifier": "~0.2.6",
    "grunt-contrib-jshint": "~0.8.0",
    "grunt-contrib-nodeunit": "~0.2.2"
  },
  "directories": {
    "example": "examples",
    "test": "test"
  },
  "keywords": [
    "i2c",
    "sensor",
    "light",
    "tsl2561"
  ],
  "license": "GPL-3.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/imwebgefunden/tsl2561_node.git"
  },
  "bugs": {
    "url": "https://github.com/imwebgefunden/tsl2561_node/issues"
  },
  "homepage": "https://github.com/imwebgefunden/tsl2561_node",
  "readme": "# Sensor TSL2561 for node.js\n---\nA node.js module for working with the light sensor TSL2561 via i2c.\n\n## About the sensor\nThe TSL2561 is a light sensor who combines one broadband photodiode (visible plus infrared) and one infrared-responding photodiode. That means you can separately measure infrared, full-spectrum or human-visible light. A breakout with the sensor is available at [adafruit](http://www.adafruit.com/products/439) or [watterott (Germany)](http://www.watterott.com/de/TSL2561-Lichtsensor).\nThis driver/module based on the [latest datasheet from ams](http://www.ams.com/eng/Products/Light-Sensors/Light-to-Digital-Sensors/TSL2561). An older version is available at [adafruit](http://www.adafruit.com/datasheets/TSL2561.pdf).\n\n## Install\n```\n$ npm install sensor_tsl2561\n```\n#### Raspberry PI\nEnable [i2c on your Pi](https://github.com/kelly/node-i2c#raspberry-pi-setup) if you haven't done already. To avoid having to run the i2c tools as root add the ‘pi’ user to the i2c group:\n```\nsudo adduser pi i2c\n```\n\n## Usage\nThe module is easy to use. You have different config-options \n\n### Simple Usage\n```\nvar TSL2561 = require('sensor_tsl2561');\n\nvar sense = new TSL2561();\nsense.init(function(err, val) {\n  if (!err) {\n    sense.getLux(function(error, val) {\n      if (!error) console.log(val + ' lux');\n    });    \n  }\n});\n```\n \n### Don't forget to call init()\n```ìnit()``` powers up the sensor and sets the given options.\n\n### Options\nThe default options are:\n```\n{\n    'debug': false,\n    'address': 0x39,\n    'device': '/dev/i2c-1',\n    'powerMode': 'powerUp',\n    'timingMode': '402ms',\n    'gainMode': '1',\n    'packageType': 'auto',\n}\n```\n\nConfigure the sensor by supplying an options object to the constructor like:\n```\nvar sense = new TSL2561({\n    'timingMode': '13.7ms',\n    'gainMode': '16'\n});\n```\n### packageType-Option\nThe sensor is available as package type \"CS\" or \"T/FN/CL\". The package types are using different lux calculation methods. You can set the package type as\n```CS```, ```T/FN/CL``` or ```auto```. If ```auto``` is set, the value from ```ID-Register``` is used to get the sensors package type. For more details on this read the id section in the old and the new manual to see the differences.\n\n### Getter & Setter for sensor settings\nGetter supports only callbacks. Setter supports callbacks and event-emitters - ```sensorSettingChanged``` and ```sensorSettingFailed```. Getter and setter are:\n```\ngetPowerMode(cB) / setPowerMode(newMode, [cB]) / modes: 'powerUp', 'powerDown'\ngetTimingMode(cB) / setTimingMode(newMode, [cB]) / modes: '13.7ms', '101ms', '402ms', 'n/a'\ngetGainMode(cB) / setGainMode(newMode, [cB]) / modes: '1', '16'\n```\n\nThe ```sensorId``` is only a getter:\n```\ngetSensorId(cB) / with 'TSL2560CS', 'TSL2561CS', 'TSL2560T/FN/CL', 'TSL2561T/FN/CL'\n```\n\n### Light-Measurements\nMeasurement-functions using a callback and some of them an event-emitter. All events including a timestamp and additional data like the address to determine the sensor, who emitted the event.\n\n* ```getLight0([cB])``` - channel 0 light value\n* ```getLight1([cB])``` - channel 1 light value\n* ```getLux([cB])``` - the calculated lux value (depends on channel 0 and 1) - emits event ```newSensorValue``` on success or ```sensorValueError``` on error\n* ```getAllValues([cB])``` - all values (raw and calculated) - emits event ```newSensorValues``` on success or ```sensorValuesError``` on error\n\n## Tests\nBecause it's not really a good idea to run test in an unknown environment all tests under test using a faked devices and not really your i2c bus. The faked device using a faked i2c-bus which is realised with the proxyquire module.\n\nTo run the complete test suite nodeunit is required. The best way is using grunt and the shipped gruntfile which comes with this module.\n\n## Examples\nAll examples are using a real device on address ```0x39``` on your i2c bus. Be carefully if you have more as one device on your i2c or/and if you don't use the default address for the sensor.\n\n## Licence\nThe licence is GPL v3 and the module is available at [Bitbucket](https://bitbucket.org/iwg/tsl2561_node) and [GitHub](https://github.com/imwebgefunden/tsl2561_node).",
  "readmeFilename": "readme.md",
  "_id": "sensor_tsl2561@0.2.2",
  "dist": {
    "shasum": "cb3000e2fc6b67e34e52d11038dba7144389af3e",
    "tarball": "http://registry.npmjs.org/sensor_tsl2561/-/sensor_tsl2561-0.2.2.tgz"
  },
  "_from": "sensor_tsl2561@latest",
  "_npmVersion": "1.3.14",
  "_npmUser": {
    "name": "imwebgefunden",
    "email": "imwebgefunden@gmail.com"
  },
  "maintainers": [
    {
      "name": "imwebgefunden",
      "email": "imwebgefunden@gmail.com"
    }
  ],
  "_shasum": "cb3000e2fc6b67e34e52d11038dba7144389af3e",
  "_resolved": "https://registry.npmjs.org/sensor_tsl2561/-/sensor_tsl2561-0.2.2.tgz"
}
